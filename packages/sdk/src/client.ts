import { Program, AnchorProvider, Idl, BN } from '@coral-xyz/anchor';
import {
  Connection,
  PublicKey,
  Keypair,
  Transaction,
  TransactionInstruction,
  SystemProgram,
  SYSVAR_CLOCK_PUBKEY,
  SYSVAR_SLOT_HASHES_PUBKEY,
} from '@solana/web3.js';
import { TOKEN_PROGRAM_ID, getAssociatedTokenAddress } from '@solana/spl-token';

import {
  ProtocolConfig,
  BlockState,
  ExplorationState,
  RigState,
  DepositReceipt,
  InitProtocolArgs,
  InitBlockArgs,
  DepositToRigArgs,
  CommitRandomnessArgs,
  RevealRandomnessArgs,
  SetParamsArgs,
  ExplorationStatus,
  RIGS_PER_EXPLORATION,
} from './types';

import {
  PROGRAM_ID,
  getProtocolConfigPDA,
  getBlockStatePDA,
  getExplorationStatePDA,
  getRigStatePDA,
  getDepositReceiptPDA,
  getBlockVaultPDA,
  getBlockVaultAuthorityPDA,
  getTreasuryVaultPDA,
} from './pdas';

import { calculateEffectiveTickets } from './utils/tickets';

// IDL will be generated by Anchor build - placeholder for type
type RigItIDL = Idl;

export class RigItClient {
  program: Program<RigItIDL>;
  provider: AnchorProvider;
  programId: PublicKey;

  constructor(
    connection: Connection,
    wallet: any, // Wallet adapter
    programId: PublicKey = PROGRAM_ID,
    idl?: RigItIDL
  ) {
    this.programId = programId;
    this.provider = new AnchorProvider(connection, wallet, {
      commitment: 'confirmed',
    });
    
    // In production, load IDL from chain or import generated IDL
    // For now, this is a placeholder
    if (idl) {
      this.program = new Program(idl, programId, this.provider);
    } else {
      throw new Error('IDL required - run anchor build first');
    }
  }

  // === Read Methods ===

  async getProtocolConfig(): Promise<ProtocolConfig | null> {
    const [pda] = getProtocolConfigPDA(this.programId);
    try {
      const account = await this.program.account.protocolConfig.fetch(pda);
      return account as unknown as ProtocolConfig;
    } catch {
      return null;
    }
  }

  async getBlockState(blockId: number): Promise<BlockState | null> {
    const [pda] = getBlockStatePDA(blockId, this.programId);
    try {
      const account = await this.program.account.blockState.fetch(pda);
      return account as unknown as BlockState;
    } catch {
      return null;
    }
  }

  async getExplorationState(blockId: number, explorationIndex: BN): Promise<ExplorationState | null> {
    const [pda] = getExplorationStatePDA(blockId, explorationIndex, this.programId);
    try {
      const account = await this.program.account.explorationState.fetch(pda);
      return account as unknown as ExplorationState;
    } catch {
      return null;
    }
  }

  async getCurrentExploration(blockId: number): Promise<ExplorationState | null> {
    const block = await this.getBlockState(blockId);
    if (!block) return null;
    
    const currentIndex = block.currentExplorationIndex.subn(1);
    if (currentIndex.ltn(0)) return null;
    
    return this.getExplorationState(blockId, currentIndex);
  }

  async getRigState(explorationKey: PublicKey, rigIndex: number): Promise<RigState | null> {
    const [pda] = getRigStatePDA(explorationKey, rigIndex, this.programId);
    try {
      const account = await this.program.account.rigState.fetch(pda);
      return account as unknown as RigState;
    } catch {
      return null;
    }
  }

  async getDepositReceipt(
    rigKey: PublicKey,
    userKey: PublicKey,
    depositNonce: BN
  ): Promise<DepositReceipt | null> {
    const [pda] = getDepositReceiptPDA(rigKey, userKey, depositNonce, this.programId);
    try {
      const account = await this.program.account.depositReceipt.fetch(pda);
      return account as unknown as DepositReceipt;
    } catch {
      return null;
    }
  }

  async getAllRigsForExploration(explorationKey: PublicKey): Promise<(RigState | null)[]> {
    const rigs: (RigState | null)[] = [];
    for (let i = 0; i < RIGS_PER_EXPLORATION; i++) {
      rigs.push(await this.getRigState(explorationKey, i));
    }
    return rigs;
  }

  async getUserDepositsForExploration(
    explorationKey: PublicKey,
    userKey: PublicKey
  ): Promise<DepositReceipt[]> {
    // Fetch all deposit accounts filtered by user
    const accounts = await this.program.account.depositReceipt.all([
      {
        memcmp: {
          offset: 8, // After discriminator
          bytes: userKey.toBase58(),
        },
      },
    ]);
    
    return accounts
      .map(a => a.account as unknown as DepositReceipt)
      .filter(d => d.exploration.equals(explorationKey));
  }

  // === Write Methods ===

  async initProtocol(args: InitProtocolArgs, rigTokenMint: PublicKey): Promise<string> {
    const [protocolConfig] = getProtocolConfigPDA(this.programId);
    
    const tx = await this.program.methods
      .initProtocol(args)
      .accounts({
        protocolConfig,
        rigTokenMint,
        admin: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .rpc();
    
    return tx;
  }

  async initBlock(args: InitBlockArgs, assetMint: PublicKey): Promise<string> {
    const [protocolConfig] = getProtocolConfigPDA(this.programId);
    const [blockState] = getBlockStatePDA(args.blockId, this.programId);
    const [blockVault] = getBlockVaultPDA(args.blockId, this.programId);
    const [blockVaultAuthority] = getBlockVaultAuthorityPDA(args.blockId, this.programId);
    
    const tx = await this.program.methods
      .initBlock(args)
      .accounts({
        protocolConfig,
        blockState,
        blockVault,
        blockVaultAuthority,
        assetMint,
        admin: this.provider.wallet.publicKey,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
      })
      .rpc();
    
    return tx;
  }

  async startExploration(blockId: number): Promise<string> {
    const [protocolConfig] = getProtocolConfigPDA(this.programId);
    const [blockState] = getBlockStatePDA(blockId, this.programId);
    
    const block = await this.getBlockState(blockId);
    if (!block) throw new Error('Block not found');
    
    const [explorationState] = getExplorationStatePDA(
      blockId,
      block.currentExplorationIndex,
      this.programId
    );
    
    const tx = await this.program.methods
      .startExploration()
      .accounts({
        protocolConfig,
        blockState,
        explorationState,
        previousExploration: null, // Simplified - add logic for rollover
        operator: this.provider.wallet.publicKey,
        systemProgram: SystemProgram.programId,
        clock: SYSVAR_CLOCK_PUBKEY,
      })
      .rpc();
    
    return tx;
  }

  async depositToRig(
    blockId: number,
    explorationIndex: BN,
    args: DepositToRigArgs,
    userRigTokenAccount?: PublicKey
  ): Promise<string> {
    const [protocolConfig] = getProtocolConfigPDA(this.programId);
    const [blockState] = getBlockStatePDA(blockId, this.programId);
    const [explorationState] = getExplorationStatePDA(blockId, explorationIndex, this.programId);
    const [rigState] = getRigStatePDA(explorationState, args.rigIndex, this.programId);
    const [depositReceipt] = getDepositReceiptPDA(
      rigState,
      this.provider.wallet.publicKey,
      args.depositNonce,
      this.programId
    );
    const [blockVault] = getBlockVaultPDA(blockId, this.programId);
    
    const block = await this.getBlockState(blockId);
    if (!block) throw new Error('Block not found');
    
    const userTokenAccount = await getAssociatedTokenAddress(
      block.assetMint,
      this.provider.wallet.publicKey
    );
    
    const config = await this.getProtocolConfig();
    
    const tx = await this.program.methods
      .depositToRig(args)
      .accounts({
        protocolConfig,
        blockState,
        explorationState,
        rigState,
        depositReceipt,
        user: this.provider.wallet.publicKey,
        userTokenAccount,
        blockVault,
        userRigTokenAccount: userRigTokenAccount || null,
        rigTokenMint: config?.rigTokenMint || null,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
        clock: SYSVAR_CLOCK_PUBKEY,
      })
      .rpc();
    
    return tx;
  }

  async commitRandomness(
    blockId: number,
    explorationIndex: BN,
    args: CommitRandomnessArgs
  ): Promise<string> {
    const [protocolConfig] = getProtocolConfigPDA(this.programId);
    const [blockState] = getBlockStatePDA(blockId, this.programId);
    const [explorationState] = getExplorationStatePDA(blockId, explorationIndex, this.programId);
    
    const tx = await this.program.methods
      .commitRandomness(args)
      .accounts({
        protocolConfig,
        blockState,
        explorationState,
        operator: this.provider.wallet.publicKey,
        clock: SYSVAR_CLOCK_PUBKEY,
      })
      .rpc();
    
    return tx;
  }

  async revealRandomness(
    blockId: number,
    explorationIndex: BN,
    args: RevealRandomnessArgs
  ): Promise<string> {
    const [protocolConfig] = getProtocolConfigPDA(this.programId);
    const [blockState] = getBlockStatePDA(blockId, this.programId);
    const [explorationState] = getExplorationStatePDA(blockId, explorationIndex, this.programId);
    
    const tx = await this.program.methods
      .revealRandomness(args)
      .accounts({
        protocolConfig,
        blockState,
        explorationState,
        operator: this.provider.wallet.publicKey,
        slotHashes: SYSVAR_SLOT_HASHES_PUBKEY,
        clock: SYSVAR_CLOCK_PUBKEY,
      })
      .rpc();
    
    return tx;
  }

  async refundLoser(depositReceiptKey: PublicKey): Promise<string> {
    const receipt = await this.program.account.depositReceipt.fetch(depositReceiptKey);
    const [blockVault] = getBlockVaultPDA(0, this.programId); // Need to derive from exploration
    const [blockVaultAuthority] = getBlockVaultAuthorityPDA(0, this.programId);
    
    // Get exploration to determine block ID
    const exploration = await this.program.account.explorationState.fetch(
      (receipt as any).exploration
    );
    
    const block = await this.getBlockState((exploration as any).blockId);
    if (!block) throw new Error('Block not found');
    
    const userTokenAccount = await getAssociatedTokenAddress(
      block.assetMint,
      this.provider.wallet.publicKey
    );
    
    const tx = await this.program.methods
      .refundLoser()
      .accounts({
        explorationState: (receipt as any).exploration,
        rigState: (receipt as any).rig,
        depositReceipt: depositReceiptKey,
        user: this.provider.wallet.publicKey,
        userTokenAccount,
        blockVault,
        blockVaultAuthority,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .rpc();
    
    return tx;
  }

  async claimWinnings(depositReceiptKey: PublicKey): Promise<string> {
    const receipt = await this.program.account.depositReceipt.fetch(depositReceiptKey);
    const [protocolConfig] = getProtocolConfigPDA(this.programId);
    
    const exploration = await this.program.account.explorationState.fetch(
      (receipt as any).exploration
    );
    
    const block = await this.getBlockState((exploration as any).blockId);
    if (!block) throw new Error('Block not found');
    
    const [blockVault] = getBlockVaultPDA((exploration as any).blockId, this.programId);
    const [blockVaultAuthority] = getBlockVaultAuthorityPDA((exploration as any).blockId, this.programId);
    
    const userTokenAccount = await getAssociatedTokenAddress(
      block.assetMint,
      this.provider.wallet.publicKey
    );
    
    const tx = await this.program.methods
      .claimWinnings()
      .accounts({
        protocolConfig,
        explorationState: (receipt as any).exploration,
        rigState: (receipt as any).rig,
        depositReceipt: depositReceiptKey,
        user: this.provider.wallet.publicKey,
        userTokenAccount,
        blockVault,
        blockVaultAuthority,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .rpc();
    
    return tx;
  }

  async emergencyPause(pause: boolean): Promise<string> {
    const [protocolConfig] = getProtocolConfigPDA(this.programId);
    
    const tx = await this.program.methods
      .emergencyPause(pause)
      .accounts({
        protocolConfig,
        authority: this.provider.wallet.publicKey,
        clock: SYSVAR_CLOCK_PUBKEY,
      })
      .rpc();
    
    return tx;
  }

  // === Utility Methods ===

  async estimateTicketWeight(amount: BN, rigBalance: BN): Promise<BN> {
    return new BN(calculateEffectiveTickets(amount.toNumber(), rigBalance.toNumber()).toString());
  }

  getExplorationPDA(blockId: number, explorationIndex: BN): PublicKey {
    const [pda] = getExplorationStatePDA(blockId, explorationIndex, this.programId);
    return pda;
  }

  getRigPDA(explorationKey: PublicKey, rigIndex: number): PublicKey {
    const [pda] = getRigStatePDA(explorationKey, rigIndex, this.programId);
    return pda;
  }
}
